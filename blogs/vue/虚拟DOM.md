---
title: 虚拟DOM
date: 2019-8-21
author: zhaipeixi
sidebar: 'auto'
tags:
 - vue
categories:
 - vue
---

### 虚拟DOM优缺点
  由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。
  一句话总结虚拟DOM就是一个用来描述真实DOM的javaScript对象,这样说可能不够形象,那我们来举个🌰:分别用代码来描述真实DOM以及虚拟DOM
  ## 真是DOM
  ```js
    <ul class="list">
      <li>a</li>
      <li>b</li>
      <li>c</li>
    </ul>
  ```
  ## 虚拟DOM
  ```js
    let vnode = h('ul.list', [
      h('li','a'),
      h('li','b'),
      h('li','c'),
    ])

    console.log(vnode)
  ```
## 优点
  1. 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
  2. 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
  3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。
  4. 复杂视图情况下提升渲染性能(操作dom性能消耗大,减少操作dom的范围可以提升性能   当某个子节点发生变化其余节点不变 不用重新渲染整个dom树 开销变小)
## 缺点
  1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
  2. 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。
## 虚拟dom库
- Snabbdom
  - Vue.js2.x内部使用的虚拟DOM就是改造的Snabbdom
  - 大约200SLOC(single line of code)
  - 通过模块可扩展
  - 源码使用TypeScript开发
  - 最快的Virtual DOM之一
- virtual-dom
## key的作用
- Diff操作可以更加快速;
- Diff操作可以更加准确;(避免渲染错误)
- 不推荐使用索引作为key

## react+vue2+vue3 diff算法分析及比较
# 介绍diff算法
1. react-diff: 递增法
   移动节点：移动的节点称为α，将α对应的真实的DOM节点移动到，α在新列表中的前一个VNode对应的真实DOM的后面
添加节点：在新列表中有全新的VNode节点，在旧列表中找不到的节点需要添加（通过find这个布尔值来查找）
移除节点：当旧的节点不在新列表中时，我们就将其对应的DOM节点移除（通过key来查找确定是否删除）
不足：从头到尾单边比较，容易增加比较次数
2. vue2-diff: 双端比较
DOM节点什么时候需要移动和如何移动，总结如下：

- 头-头：不移动
- 尾-尾：不移动
- 头-尾: 插入到旧节点的尾节点的后面
- 尾-头：插入到旧列表的第一个节点之前
- 以上4种都不存在（特殊情况）：在旧节点中找，如果找到，移动找到的节点，移动到开头；没找到，直接创建一个新的节点放到最前面

添加节点【oldEndIndex以及小于了oldStartIndex】：将剩余的节点依次插入到oldStartNode的DOM之前
移除节点【newEndIndex小于newStartIndex】：将旧列表剩余的节点删除即可
# 区别
1. react和vue2的比较：
- vue2双端比较解决react单端比较导致移动次数变多的问题，react只能从头到尾遍历，增加了移动次数
2. vue2和vue3的比较：都用了双端指针
3. vue3和react比较：vue3在判断是否需要移动，使用了react的递增法

几个算法看下来，套路就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。

## 怎么理解虚拟dom
  在js中,渲染真实DOM的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实DOM, 会引起整个dom树的重绘和重排。那么有没有可能实现只更新我们修改的那一小块dom而不要更新整个DOM
  我们就需要先根据真实dom生成虚拟dom， 当虚拟dom某个节点的数据改变后会生成有一个新的Vnode, 然后新的Vnode和旧的Vnode作比较，发现有不一样的地方就直接修改在真实DOM上，然后使旧的Vnode的值为新的Vnode。

  diff的过程就是调用<font color='red'>patch</font>函数，比较新旧节点，一边比较一边给真实的DOM打补丁。在采取diff算法比较新旧节点的时候，比较只会在同层级进行。
  在patch方法中，首先进行树级别的比较 new Vnode不存在就删除old Vnode   old Vnode不存在就增加新的Vnode  都存在就执行diff更新
  当确定需要执行diff算法时，比较两个Vnode,
  包括三种类型操作：属性更新，文本更新，子节点更新 调用 updatechidren 函数
  新老节点均有子节点，则对子节点进行diff操作，调用 <font color='red'>updatechidren</font>
  如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点
  如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点
  老新老节点都没有子节点的时候，进行文本的替换
 