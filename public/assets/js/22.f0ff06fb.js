(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{529:function(t,o,e){"use strict";e.r(o);var r=e(6),n=Object(r.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"什么是原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型"}},[t._v("#")]),t._v(" 什么是原型")]),t._v(" "),e("ul",[e("li",[t._v("我们都知道每个函数都有一个prototype属性，(定义函数时自动添加的)，它默认指向一个Object空对象，叫做显示原型对象，JS引擎会自动给显示原型对象添加一个constructor属性，属性值指向构造函数对象本身，同时该函数的每一个实例对象上都有一个_proto_的属性，该属性也是一个对象，叫做隐式原型对象，与其构造函数的显示原型对象是同一个对象(person."),e("em",[t._v("proto")]),t._v("===Person.prototype)")])]),t._v(" "),e("h2",{attrs:{id:"作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用：")]),t._v(" "),e("ul",[e("li",[t._v("节省内存空间  节省代码量  实现继承")])]),t._v(" "),e("h2",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链：")]),t._v(" "),e("ul",[e("li",[t._v("访问一个对象的属性时，先在自身属性中查找，找到返回，如果没有再沿着_proto_这条链向上查找，找到返回，最终会找到Object.prototype上(Object._proto_是null),如果没有返回undefined，继续调用则报错，这就是原型链，又叫隐式原型链")])]),t._v(" "),e("h2",{attrs:{id:"三条特殊"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三条特殊"}},[t._v("#")]),t._v(" 三条特殊：")]),t._v(" "),e("ul",[e("li",[t._v("第一条是Function."),e("em",[t._v("proto")]),t._v("=== Function.prototype,说明Function是new它自己产生的，第二条是Function.prototype._proto_指向Object.prototype,其实Function 底层是不是用js写的，我们也可以console.log打印，可以清除的看到他和其他的显示原型的显示结果不一样，其他的都是一个普通的Object对象，但是他打印出来是一个函数，ƒ () { [native code] } ，里边写了native code ，但是js为了完成性，将其也指向了Object.prototype，第三条就是Object的显示原型对象的隐式原型是null，最为原型链的尽头，将原型链中断\n"),e("img",{attrs:{src:"https://coolcdn.igetcool.com/p/2020/8/37127d77d76c1e66d764b32fcdf4d503.png?_598x715.png",alt:"原型链"}})])])])}),[],!1,null,null,null);o.default=n.exports}}]);