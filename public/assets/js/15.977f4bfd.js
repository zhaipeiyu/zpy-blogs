(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{522:function(t,a,r){"use strict";r.r(a);var e=r(6),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"http缓存-两种"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http缓存-两种"}},[t._v("#")]),t._v(" http缓存(两种)")]),t._v(" "),r("h2",{attrs:{id:"_1-强制缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-强制缓存"}},[t._v("#")]),t._v(" 1. 强制缓存")]),t._v(" "),r("p",[t._v("强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以Ctrl + F5一顿操作之后就好了。")]),t._v(" "),r("h2",{attrs:{id:"_2-协商缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-协商缓存"}},[t._v("#")]),t._v(" 2. 协商缓存")]),t._v(" "),r("p",[t._v("当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。")])])}),[],!1,null,null,null);a.default=s.exports}}]);