(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{527:function(a,s,n){"use strict";n.r(s);var t=n(6),e=Object(t.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"异步编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[a._v("#")]),a._v(" 异步编程")]),a._v(" "),n("h2",{attrs:{id:"_1-前置知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-前置知识"}},[a._v("#")]),a._v(" 1. 前置知识")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('1). JS语言的执行环境是"单线程", 也就是我们写的所有js代码都是在一个线程(主线程)上执行\n2). 理解单线程: \n    就是指一次只能完成一件任务。\n    如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推\n3). js执行任务的2种模式\n    同步（Synchronous）: \n        后一个任务等待前一个任务结束，然后再执行，\n        程序的执行顺序与任务的排列顺序是一致的、同步的\n    异步（Asynchronous）\n        每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，\n        后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n4). 为什么需要异步JS?\n    浏览器端: \n        耗时很长的操作都应该异步执行，避免浏览器失去响应\n        给时机让浏览器能去更新界面, 响应用户操作\n    Node端:\n        "异步模式"是唯一的模式，执行环境是单线程的\n        处理请求的回调函数/数据库操作/文件读写操作都必须是异步处理, 否则处理多个请求时很快就会失去响应\n5). JS常用的异步编码方式\n    a. 回调函数\n    b. 事件机制\n    c. 消息订阅与发布 / 全局事件总线\n    d. Promise\n')])])]),n("h2",{attrs:{id:"_2-回调函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-回调函数"}},[a._v("#")]),a._v(" 2. 回调函数")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("异步编程最基本的方法, 所有模式都是在此基础上进行封装扩展而来\n回调函数的执行模式:\n    异步执行\n    同步执行\n异步回调的缺点: \n    不利于代码的阅读和维护，各个部分之间高度耦合。\n    容易导致回调地狱问题\n")])])]),n("h2",{attrs:{id:"_3-事件监听"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件监听"}},[a._v("#")]),a._v(" 3. 事件监听")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("事件驱动模式: \n    任务的执行不取决于代码定义的顺序，而取决于某个事件是否发生\n    事件监听函数定义时不会执行, 只有当事件发生(分发事件)后才执行\n分类:\n    原生DOM事件\n    自定义事件\n操作:\n    在某个元素/组件对象上绑定特定事件监听\n    在某个元素/组件对象上分发事件\n特点:\n    针对某个DOM元素绑定监听和分发事件\n    针对某个组件对象绑定监听和分发事件\n")])])]),n("h2",{attrs:{id:"_4-消息订阅-发布与全局事件总线"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-消息订阅-发布与全局事件总线"}},[a._v("#")]),a._v(" 4. 消息订阅/发布与全局事件总线")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("消息订阅/发布:\n    订阅全局消息\n    发布全局消息\n全局事件总线:\n    绑定事件监听\n    分发事件\n特点:\n    分发事件后, 所有同名的事件监听回调都会调用\n")])])]),n("h2",{attrs:{id:"_5-promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise"}},[a._v("#")]),a._v(" 5. Promise")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("实现异步编程新的通用解决方案\n相对于纯回调的优势\n    指定异步回调函数的方式更灵活(可以在启动异步任务后,甚至可以在异步任务完成后)\n    通过then的链式调用解决回调地狱的问题\n不足: 还需要指定回调函数\n")])])]),n("h2",{attrs:{id:"_6-async-await"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-async-await"}},[a._v("#")]),a._v(" 6. async/await")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("基于promise的语法糖, 简化了promise对象的使用(不再使用回调函数编码)\n以同步编码方式实现的异步流程\n是js异步编程的终极解决方案(基本上可以这样说)\n")])])]),n("h2",{attrs:{id:"_7-js事件循环机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-js事件循环机制"}},[a._v("#")]),a._v(" 7. JS事件循环机制")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("js是单(主)线程运行的\njs的回调函数可以异步执行\njs通过event-loop机制实现了js的单线程异步执行\n    JS引擎解析执行js代码总是在主线程执行(WebWorks除外)\n    浏览器有在分线程执行的对应管理模块(浏览器是多线程执行的)\n        定时器\n        DOM事件监听\n        ajax请求\n        Promise\n    JS引擎有专门的回调队列, 缓存待执行的回调函数\n        宏队列\n        微队列\n")])])]),n("h2",{attrs:{id:"事件循环机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制"}},[a._v("#")]),a._v(" 事件循环机制")]),a._v(" "),n("ol",[n("li",[a._v("js是单线程的，所有的代码都会在js的主线程执行")]),a._v(" "),n("li",[a._v("异步任务(定时器，事件的回调，网络请求)不会立马执行结束，会交由对应的管理模块去管理")]),a._v(" "),n("li",[a._v("对应的管理模块在异步任务满足条件之后将对应的回调函数放在callback queue中")]),a._v(" "),n("li",[a._v("主线程上同步任务执行完毕会询问callback queue中是否有可执行的回调，如果有，就将回调函数钩出去放在主线程执行")]),a._v(" "),n("li",[a._v("主线程上的代码执行结束后会反复的去问，又叫event loop ----\x3e 事件轮询机制")])])])}),[],!1,null,null,null);s.default=e.exports}}]);